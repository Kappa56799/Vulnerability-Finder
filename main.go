//Author: Kacper Palka palka@kacper.boo
//Description: A script which allows you to scan files/folders for vulnerabilities using OpenAI's GPT-4 model. It has a blocklist feature to ignore certain files based on patterns.

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"encoding/json"
	"time"
	"github.com/go-resty/resty/v2"
	"github.com/briandowns/spinner"
)

// struct to store file data, including name, path, and content
type FileData struct {
	FileName string
	FilePath string
	FileData string
}

// Constant variables and global variables
var APIKey = os.Getenv("OPENAI_API_KEY")
const APIEndpoint = "https://api.openai.com/v1/chat/completions"
var data map[string]interface{}

func main() {
	var fileData []FileData
	var blockList map[string]bool

  // Check if the user inputted any files or folders to check
	if len(os.Args) < 2 {
		fmt.Println("Please provide a folder or files to process.")
		return
	}

  // Read all the files and folders the user inputted
	files := os.Args[1:]

	// Read blocklist from a file
	blockList = readBlockList("blocklist.txt")

	// Create the report file
	outputFile, err := os.OpenFile("report.txt", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
	if err != nil {
		fmt.Println("Error opening output file:", err)
		return
	}
	outputFile.Close()

	// Process files and folders
	processFileData(files, &fileData, blockList)

	// Query GPT-4 with the processed file data
	queryGPT(fileData, outputFile)
}

// Reads blocklist from a file and stores it in a map
func readBlockList(filename string) map[string]bool {
	blockList := make(map[string]bool)

	file, err := os.Open(filename)
	if err != nil {
		fmt.Println("Error reading blocklist:", err)
		return blockList
	}
	file.Close()

  // Reads the blocklist file line by line and stores it in a hashmap
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" {
			blockList[line] = true
		}
	}

	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading blocklist:", err)
	}

	return blockList
}

// Process files and folders to collect file data, while ignoring files in the blocklist
func processFileData(files []string, fileData *[]FileData, blockList map[string]bool) {
	for _, file := range files {
		fileInfo, err := os.Stat(file)
		if err != nil {
			fmt.Println("Error reading file:", err)
			continue
		}

		// If it's a directory, walk through its contents
		if fileInfo.IsDir() {
			err = filepath.Walk(file, func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if !info.IsDir() && !isBlocked(info.Name(), blockList) {
					readAndStoreFileData(path, fileData)
				}
				return nil
			})
			if err != nil {
				fmt.Println("Error walking directory:", err)
			}
		} else {
			if !isBlocked(fileInfo.Name(), blockList) {
				readAndStoreFileData(file, fileData)
			}
		}
	}
}

// Check if a file is blocked based on blocklist patterns
func isBlocked(fileName string, blockList map[string]bool) bool {
	// Check for exact filename matches or wildcard extensions (e.g., *.log)
	for pattern := range blockList {
		if pattern[0] == '*' && strings.HasSuffix(fileName, pattern[1:]) {
			return true
		}
		if pattern == fileName {
			return true
		}
	}
	return false
}

// Read file content and store it in the fileData slice
func readAndStoreFileData(filePath string, fileData *[]FileData) {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	fileInfo := FileData{
		FileName: filepath.Base(filePath),
		FilePath: filePath,
		FileData: string(data),
	}

	*fileData = append(*fileData, fileInfo)
}

// Query GPT-4 for vulnerabilities in the files
func queryGPT(fileData []FileData, outputFile *os.File) {
	s := spinner.New(spinner.CharSets[33], 100*time.Millisecond)
	client := resty.New()

	for _, file := range fileData {
		s.Start()

		input := "Find all or any vulnerabilities in this code: " + file.FileData

		// Query GPT-4 API
		response, err := client.R().
			SetAuthToken(APIKey).
			SetHeader("Content-Type", "application/json").
			SetBody(map[string]interface{}{
				"model": "gpt-4",
				"messages": []interface{}{
					map[string]interface{}{
						"role":    "user",
						"content": input,
					},
				},
				"max_tokens": 3000,
			}).
			Post(APIEndpoint)

		// Stop the spinner before processing the response
		s.Stop()

		if err != nil {
			fmt.Println("Error:", err)
			return
		}

		// Parse the response body which is in JSON
		body := response.Body()
		err = json.Unmarshal(body, &data)
		if err != nil {
			fmt.Println("Error parsing JSON:", err)
			return
		}

		// Extract the content from the response
		content := data["choices"].([]interface{})[0].(map[string]interface{})["message"].(map[string]interface{})["content"].(string)

		// Write the vulnerabilities to the report.txt file
		showVulnerabilities(content, file, outputFile)
	}
}

// Show vulnerabilities for a given file and write to the report.txt file
func showVulnerabilities(content string, file FileData, outputFile *os.File) {
	result := "-----------------------------------------------------------------\n"
	result += fmt.Sprintf("Vulnerabilities for file: %s\n", file.FilePath)
	result += "-----------------------------------------------------------------\n"
	result += fmt.Sprintf("%s\n\n", content)

	// Print to the console
	fmt.Println(result)

	// Write to the report file
	_, err := outputFile.WriteString(result)
	if err != nil {
		fmt.Println("Error writing to output file:", err)
	}
}
